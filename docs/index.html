<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>illusory</title>
    <link rel="stylesheet" href="./index.css">
    <link href="/prism.css" rel="stylesheet" />
</head>

<body>
    <h1>illusory</h1>
    <p>Seamlessly morph one element into another.</p>

    <div class="first-demo">
        <svg class="first-demo--0" width="200" height="200" viewBox="0 0 1703 1081" xmlns="http://www.w3.org/2000/svg"
            fill="currentColor" fill-rule="evenodd" clip-rule="evenodd" stroke-linejoin="round" stroke-miterlimit="2">
            <circle cx="3644.8" cy="1962.31" r="22.166" transform="matrix(7.66518 0 0 7.66634 -27767.317 -14133.19)">
            </circle>
            <path
                d="M1356.075.476h346.7v346.7h-346.7zM794.584.474v736.428c0 91.69-36.64 179.546-101.717 244.097-65.078 64.474-153.304 100.275-244.903 99.509h-.076V.474h346.696zm107.236 0h346.695v1079.988H901.82z">
            </path>
        </svg>

        <div class="first-demo--2 hidden">
            I'm a div
        </div>
        <input class="first-demo--1 hidden" placeholder="I'm a text input">
        <img src="/andrew-neel-a_K7R1kugUE-unsplash.jpg" class="first-demo--3 hidden">
    </div>

    <h2>How it works</h2>
    <p>
        <code>illusory</code> makes it look as though one element is capable of morphing into
        another, no
        matter where the two elements are in the DOM.
        <br>
        <br>
        It does so by making copies of the two elements (and, optionally, all their children), setting a fixed position
        on each, then
        using CSS <code class="lang-css">transform</code>, <code class="lang-css">opacity</code>, and <code
            class="lang-css">border-radius</code>
        to morph the two elements in sync.
    </p>
    <script class="lang-js" type="text/plain">
        illusory(from, to)
    </script>
    <div class="example-1" data-duration="2s">
        <button class="play"></button>
        <div class="from">
            A
        </div>
        <div class="to">
            B
        </div>
    </div>
    <h3>illusory(): Promise</h3>
    <p>illusory return a <code class="lang-js">Promise</code> that resolves when the animation is complete.</p>
    <script class="lang-js" type="text/plain">
                await illusory(from, to) // or .then
                illusory(to, from)
            </script>
    <div class="example-2" data-duration="2s">
        <button class="play"></button>
        <div class="from">
            A
        </div>
        <div class="to">
            B
        </div>
    </div>
    <hr>
    <h2>Options</h2>
    <h3>Overview:</h3>
    <script class="lang-js" type="text/plain">
        interface IOptions {
            includeChildren: boolean
            compositeOnly: boolean
            duration: string
            easing: string
            zIndex: number
            deltaHandlers?: {
                [property: string]: DeltaHandlerFunction | false
            }
            beforeAttach?: (from: IllusoryElement, to: IllusoryElement) => void | Promise<void>
            beforeAnimate?: (from: IllusoryElement, to: IllusoryElement) => void | Promise<void>
            beforeDetach?: (from: IllusoryElement, to: IllusoryElement) => void | Promise<void>
        }
    </script>
    <h3>duration: string</h3>
    <h5>Default: '300ms'</h5>
    <p>A CSS &lt;time&gt;.
        <br>e.g. 2s, 150ms, etc.</p>
    <script class="lang-js" type="text/plain">
            illusory(from, to, {
                duration: '10s'
            })
        </script>
    <div class="example-3" data-duration="10s">
        <button class="play"></button>
        <div class="from">
            A
        </div>
        <div class="to">
            B
        </div>
    </div>
    <h3>easing: string</h3>
    <h5>Default: 'ease'</h5>
    <p>A CSS &lt;timing-function&gt;.
        <br>e.g. ease-out, cubic-bezier(.29, 1.01, 1, -0.68), etc.</p>
    <script class="lang-js" type="text/plain">
                illusory(from, to, {
                    easing: 'cubic-bezier(.54,.03,.36,1.7)'
                })
            </script>
    <div class="example-3" data-easing="cubic-bezier(.54,.03,.36,1.7)" data-duration="1s">
        <button class="play"></button>
        <div class="from">
            A
        </div>
        <div class="to">
            B
        </div>
    </div>
    <h3>compositeOnly: boolean</h3>
    <h5>Default: false</h5>
    <p>Used to limit the animation to <code class="lang-css">transform</code>
        and <code class="lang-css">opacity</code>.
        <br>Notice that the <code class="lang-css">border-radius</code> is not
        animated.</p>
    <script class="lang-js" type="text/plain">
                    illusory(from, to, {
                        compositeOnly: true
                    })
                </script>
    <div class="example-3" data-composite-only="true" data-duration="2s">
        <button class="play"></button>
        <div class="from">
            A
        </div>
        <div class="to">
            B
        </div>
    </div>
    <h3>includeChildren: boolean</h3>
    <h5>Default: true</h5>
    <p>If true, a deep clone is performed so that the children are included in the animation</p>
    <script class="lang-js" type="text/plain">
        illusory(from, to, {
            includeChildren: false
        })
    </script>
    <div class="example-3" data-include-children="" data-duration="2s">
        <button class="play"></button>
        <div class="from">
            A
        </div>
        <div class="to">
            B
        </div>
    </div>
    <h3>zIndex: number</h3>
    <h5>Default: 1</h5>
    <p>Used to set the z-index of the cloned elements.</p>
    <h3>deltaHandlers: Object</h3>
    <p>
        An object where the keys are css properties and the values are either <code class="lang-js">false</code>
        (disabled) or a function that returns a new value for the repective property.
    </p>
    <p>For example, the following disables the handlers for transform and border-top-left-radius and creates a new
        handler for <code class="lang-css">background-color</code> that always returns <code
            class="lang-js">"red"</code>.</p>
    <p>While this example is not very practical, it illustrates how easily deltaHandlers can be used to change the look
        of the animation.</p>
    <script class="lang-js" type="text/plain">
        illusory(from, to, {
            deltaHandlers: {
                transform: false,
                borderTopLeftRadius: false,
                backgroundColor(delta, deltaStyle, thisStyle) {
                    return 'red'
                }
            }
        })
    </script>
    <div class="example-4" data-duration="2s">
        <button class="play"></button>
        <div class="from">
            A
        </div>
        <div class="to">
            B
        </div>
    </div>
    <hr>
    <h2>Advanced</h2>

    <h3>IllusoryElement</h3>
    <h5>constructor(el: Element, options?)</h5>

    <script class="lang-js" type="text/plain">
        const el = document.querySelector('#el')

        const illusoryElement = new IllusoryElement(el)
        // or
        const illusoryElement = new IllusoryElement(el, { /* options */})
    </script>
    <h4>options</h4>
    <script class="lang-js" type="text/plain">
            {
                includeChildren: boolean
                zIndex: number
                deltaHandlers?: {
                    [property: string]: DeltaHandlerFunction | false
                }
            }
        </script>

    <hr>
    <h4>Properties</h4>
    <h5>natural</h5>
    <p>The original element (e.i. not the clone).</p>
    <script class="lang-js" type="text/plain">
                illusoryElement.natural === el // true
    </script>
    <hr>
    <h5>clone</h5>
    <p>A clone of the "natural" element.</p>
    <hr>
    <h5>rect</h5>
    <p>The <code class="lang-js">DOMRect</code> of the "natural" element as returned by <code
            class="lang-js">getBoundingClientRect()</code> at the time the IllusoryElement was created.</p>
    <hr>
    <h4>Methods</h4>

    <h5>getStyle(property: string)</h5>
    <p>Returns the orignal style value for the given property.
    </p>
    <blockquote><strong>Note:</strong> CSS shorthand properties are not supported (background, border-radius, etc.).
        Instead use
        background-color, background-image, border-bottom-right-radius, etc.</blockquote>
    <hr>
    <h5>setStyle(property: string, value: string)</h5>
    <p>
        Sets the given css style on the cloned element.
    </p>
    <blockquote>Changes made using this method will not be reflected by <code class="lang-js">getStyle</code>.
    </blockquote>
    <script class="lang-js" type="text/plain">
        illusoryElement.clone.style.backgroundColor // #fff

        illusoryElement.setStyle('backgroundColor', '#000')

        illusoryElement.clone.style.backgroundColor // #000
        
        illusoryElement.getStyle('backgroundColor') // #fff

    </script>
    <p>
        That is to say, if the backgroundColor is <code class="lang-css">#fff</code> and you call <code
            class="lang-js">setStyle('backgroundColor', '#000')</code>, <code
            class="lang-js">getStyle('backgroundColor')</code> will still return <code class="lang-css">#fff</code> even
        though the element's background is actually black. This behavior makes it easier to author "Delta Handlers"
    </p>
    <hr>
    <h5>waitFor(property: string): Promise&lt;void&gt;
    </h5>
    <p>Returns a promises that resolves when the cloned element emits a <code class="lang-js">"transitionend"</code>
        event for the given property. If <code class="lang-js">"any"</code> is passed, the promise will resolve on the
        first <code class="lang-js">"transitionend"</code> regardless of the property</p>
    <hr>
    <h5>hide()</h5>
    <p>Hides the cloned element</p>
    <hr>
    <h5>show()</h5>
    <p>Shows the cloned element</p>
    <hr>
    <h5>hideNatural()</h5>
    <p>Hides the natural element</p>
    <hr>
    <h5>showNatural()</h5>
    <p>Shows the natural element</p>
    <hr>
    <h5>flushCSS()</h5>
    <p>Forces the browser to apply any style changes that might be queued.</p>
    <blockquote>Useful for applying any css changes before setting a transition on the element.</blockquote>
    <hr>
    <h5>detach</h5>
    <p>Removes the clone and cleans up styles applied to the natural element.</p>
    <hr>
    <h3>IllusoryElement and 2-part morphing</h3>
    <p>Sometimes your elements will not be in the DOM at the same time (e.g. SPA route change). In that case you will
        need to perform the
        animation in two parts. Create an IllusoryElement to capture the element in advance.</p>
    <script class="lang-js" type="text/plain">
        const el = document.querySelector('#from')
        // Save for later
        const from = new IllusoryElement(el, /* options */)
        el.remove()

        // Later...
        const to = document.createElement('img')
        document.body.appendChild(to)

        illusory(from, to)
    </script>

    <hr>

    <h2>Hooks</h2>
    <blockquote>
        If any hook returns a promise, illusory will wait for the promise to resolve.
    </blockquote>
    <h4>beforeAttach(from, to)</h4>
    <p>Called after the clone is created, but before the clone is appended to the DOM</p>
    <h4>beforeAnimate(from, to)</h4>
    <p>Called after the clone is appended to the DOM and the natural element has been hidden, but before the animation
        begins</p>
    <h4>beforeDetach(from, to)</h4>
    <p>Called after the animation is completed, but before the clone is removed from the DOM</p>
    <hr>
    <h3>Example of using hooks</h3>
    <script class="lang-js" type="text/plain">
        illusory(from, to, {
            includeChildren: false,
            async beforeAnimate(from, to) {
                // Show the natural element and hide the clone
                // because by default the clone has already
                // been replaced the natural element
                from.showNatural()
                from.hide()
                
                // Set the clone to animate opacity
                from.setStyle('transition', 'opacity 0.5s')
                // Force the style changes to be rendered
                from.flushCSS()
                
                // Show the clone and wait for it fade in
                from.show()
                await from.waitFor('opacity')
                
                from.hideNatural()
            },
            beforeDetach(from, to) {
                from.hide()

                to.showNatural()

                to.setStyle('transition', 'opacity 0.5s')
                to.hide()

                return to.waitFor('opacity')
            }
        })
    </script>
    <div class="example-5" data-include-children="" data-duration="2s">
        <button class="play"></button>
        <div class="from">
            A
        </div>
        <div class="to">
            B
        </div>
    </div>
    <script src="./illusory.js"></script>
    <!--
    <script>
        if (location.origin !== 'localhost')
            document.write('<script src="https://unpkg.com/illusory">\<\/script>')
        else
            document.write('<script src="/illusory.js">\<\/script>')

    </script> -->
    <script src="https://cdn.jsdelivr.net/npm/es6-promise@4/dist/es6-promise.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/es6-promise@4/dist/es6-promise.auto.min.js"></script>
    <script src="/prism.js"></script>
    <script src="./index.es5.js"></script>
</body>

</html>
